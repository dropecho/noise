// Generated by Haxe 4.3.0
(function ($hx_exports, $global) { "use strict";
$hx_exports["dropecho"] = $hx_exports["dropecho"] || {};
$hx_exports["dropecho"]["noise"] = $hx_exports["dropecho"]["noise"] || {};
$hx_exports["dropecho"]["noise"]["_Voronoi"] = $hx_exports["dropecho"]["noise"]["_Voronoi"] || {};
;$hx_exports["dropecho"]["utils"] = $hx_exports["dropecho"]["utils"] || {};
$hx_exports["dropecho"]["utils"]["_Vector"] = $hx_exports["dropecho"]["utils"]["_Vector"] || {};
var $estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
class EReg {
	constructor(r,opt) {
		this.r = new RegExp(r,opt.split("u").join(""));
	}
	match(s) {
		if(this.r.global) {
			this.r.lastIndex = 0;
		}
		this.r.m = this.r.exec(s);
		this.r.s = s;
		return this.r.m != null;
	}
	matched(n) {
		if(this.r.m != null && n >= 0 && n < this.r.m.length) {
			return this.r.m[n];
		} else {
			throw haxe_Exception.thrown("EReg::matched");
		}
	}
}
EReg.__name__ = true;
Math.__name__ = true;
class Std {
	static string(s) {
		return js_Boot.__string_rec(s,"");
	}
	static parseInt(x) {
		let v = parseInt(x);
		if(isNaN(v)) {
			return null;
		}
		return v;
	}
}
Std.__name__ = true;
class dropecho_noise_Abs {
	constructor(input) {
		this.input = input;
	}
	value(x,y) {
		let f = this.input.value(x,y);
		if(f < 0) {
			return -f;
		} else {
			return f;
		}
	}
}
$hx_exports["dropecho"]["noise"]["Abs"] = dropecho_noise_Abs;
dropecho_noise_Abs.__name__ = true;
class dropecho_noise_Add {
	constructor(input,input2) {
		this.input2 = input2;
		this.input = input;
	}
	value(x,y) {
		return this.input.value(x,y) + this.input2.value(x,y);
	}
}
$hx_exports["dropecho"]["noise"]["Add"] = dropecho_noise_Add;
dropecho_noise_Add.__name__ = true;
class dropecho_noise_Blend {
	constructor(from,to,blender) {
		this.to = to;
		this.from = from;
		this.blender = blender;
	}
	value(x,y) {
		return this.lerp(this.from.value(x,y),this.to.value(x,y),(this.blender.value(x,y) + 1.0) / 2.0);
	}
	lerp(v0,v1,t) {
		return v0 + t * (v1 - v0);
	}
}
$hx_exports["dropecho"]["noise"]["Blend"] = dropecho_noise_Blend;
dropecho_noise_Blend.__name__ = true;
class dropecho_noise_Cache {
	constructor(input) {
		this.cache = new haxe_ds_ObjectMap();
		this.input = input;
	}
	value(x,y) {
		let point = { x : x, y : y};
		if(this.cache.h.__keys__[point.__id__] == null) {
			this.cache.set(point,this.input.value(x,y));
		}
		return this.cache.h[point.__id__];
	}
}
$hx_exports["dropecho"]["noise"]["Cache"] = dropecho_noise_Cache;
dropecho_noise_Cache.__name__ = true;
class dropecho_noise_CheckerBoard {
	constructor(frequency) {
		if(frequency == null) {
			frequency = 1;
		}
		this.frequency = frequency;
	}
	value(x,y) {
		if(((x * this.frequency | 0) + (y * this.frequency | 0)) % 2 == 0) {
			return 1;
		} else {
			return -1;
		}
	}
}
$hx_exports["dropecho"]["noise"]["CheckerBoard"] = dropecho_noise_CheckerBoard;
dropecho_noise_CheckerBoard.__name__ = true;
class dropecho_noise_Clamp {
	constructor(input,min,max) {
		if(max == null) {
			max = 1;
		}
		if(min == null) {
			min = -1;
		}
		this.min = min;
		this.max = max;
		this.input = input;
	}
	value(x,y) {
		return Math.min(Math.max(this.input.value(x,y),this.min),this.max);
	}
}
$hx_exports["dropecho"]["noise"]["Clamp"] = dropecho_noise_Clamp;
dropecho_noise_Clamp.__name__ = true;
class dropecho_noise_Cones {
	constructor(frequency) {
		if(frequency == null) {
			frequency = 1;
		}
		this.frequency = frequency;
	}
	value(x,y) {
		let x1 = x * this.frequency - ((x * this.frequency | 0) + 0.5);
		let y1 = y * this.frequency - ((y * this.frequency | 0) + 0.5);
		return 1 - Math.sqrt(x1 * x1 + y1 * y1) * 4;
	}
}
$hx_exports["dropecho"]["noise"]["Cones"] = dropecho_noise_Cones;
dropecho_noise_Cones.__name__ = true;
class dropecho_noise_Constant {
	constructor(constant) {
		this.constant = constant;
	}
	value(x,y) {
		return this.constant;
	}
}
$hx_exports["dropecho"]["noise"]["Constant"] = dropecho_noise_Constant;
dropecho_noise_Constant.__name__ = true;
class dropecho_noise_Displace {
	constructor(input,xModule,yModule) {
		this.same_module = false;
		this.power = 100;
		this._input = input;
		this._xModule = xModule;
		if(yModule == null) {
			this.same_module = true;
			this._yModule = xModule;
		} else {
			this._yModule = yModule;
		}
	}
	value(x,y) {
		let xval = this._xModule.value(x,y);
		let yval = this.same_module ? xval : this._yModule.value(x,y);
		return this._input.value(xval * this.power + x,yval * this.power + y);
	}
}
$hx_exports["dropecho"]["noise"]["Displace"] = dropecho_noise_Displace;
dropecho_noise_Displace.__name__ = true;
class dropecho_noise_Max {
	constructor(input,input2) {
		this.input2 = input2;
		this.input = input;
	}
	value(x,y) {
		let a = this.input.value(x,y);
		let b = this.input2.value(x,y);
		if(a > b) {
			return a;
		} else {
			return b;
		}
	}
}
$hx_exports["dropecho"]["noise"]["Max"] = dropecho_noise_Max;
dropecho_noise_Max.__name__ = true;
class dropecho_noise_Min {
	constructor(input,input2) {
		this.input2 = input2;
		this.input = input;
	}
	value(x,y) {
		let a = this.input.value(x,y);
		let b = this.input2.value(x,y);
		if(a < b) {
			return a;
		} else {
			return b;
		}
	}
}
$hx_exports["dropecho"]["noise"]["Min"] = dropecho_noise_Min;
dropecho_noise_Min.__name__ = true;
class dropecho_noise_Multiply {
	constructor(input,input2) {
		this.input2 = input2;
		this.input = input;
	}
	value(x,y) {
		return this.input.value(x,y) * this.input2.value(x,y);
	}
}
$hx_exports["dropecho"]["noise"]["Multiply"] = dropecho_noise_Multiply;
dropecho_noise_Multiply.__name__ = true;
class dropecho_noise_Perlin {
	constructor(octaves,frequency,amplitude,lacunarity,persistence) {
		if(persistence == null) {
			persistence = 1;
		}
		if(lacunarity == null) {
			lacunarity = 2;
		}
		if(amplitude == null) {
			amplitude = 1;
		}
		if(frequency == null) {
			frequency = 1;
		}
		if(octaves == null) {
			octaves = 1;
		}
		this.persistence = persistence;
		this.octaves = octaves;
		this.lacunarity = lacunarity;
		this.frequency = frequency;
		this.amplitude = amplitude;
	}
	value(x,y) {
		let val = 0;
		let amp = this.amplitude;
		let freq = this.frequency;
		let _g = 0;
		let _g1 = this.octaves;
		while(_g < _g1) {
			++_g;
			let x1 = x * freq;
			let y1 = y * freq;
			let xf = x1 | 0;
			let yf = y1 | 0;
			let xf1 = xf + 1;
			let yf1 = yf + 1;
			let df = x1 - xf;
			let i = yf % 16 * 16 + xf % 16;
			let g_vect;
			if(dropecho_noise_Perlin.gradients[i] != null) {
				g_vect = dropecho_noise_Perlin.gradients[i];
			} else {
				let theta = Math.random() * 2 * Math.PI;
				g_vect = dropecho_noise_Perlin.gradients[i] = { x : Math.cos(theta), y : Math.sin(theta)};
			}
			let top_left = (x1 - xf) * g_vect.x + (y1 - yf) * g_vect.y;
			let i1 = yf % 16 * 16 + xf1 % 16;
			let g_vect1;
			if(dropecho_noise_Perlin.gradients[i1] != null) {
				g_vect1 = dropecho_noise_Perlin.gradients[i1];
			} else {
				let theta = Math.random() * 2 * Math.PI;
				g_vect1 = dropecho_noise_Perlin.gradients[i1] = { x : Math.cos(theta), y : Math.sin(theta)};
			}
			let top_right = (x1 - xf1) * g_vect1.x + (y1 - yf) * g_vect1.y;
			let i2 = yf1 % 16 * 16 + xf % 16;
			let g_vect2;
			if(dropecho_noise_Perlin.gradients[i2] != null) {
				g_vect2 = dropecho_noise_Perlin.gradients[i2];
			} else {
				let theta = Math.random() * 2 * Math.PI;
				g_vect2 = dropecho_noise_Perlin.gradients[i2] = { x : Math.cos(theta), y : Math.sin(theta)};
			}
			let bottom_left = (x1 - xf) * g_vect2.x + (y1 - yf1) * g_vect2.y;
			let i3 = yf1 % 16 * 16 + xf1 % 16;
			let g_vect3;
			if(dropecho_noise_Perlin.gradients[i3] != null) {
				g_vect3 = dropecho_noise_Perlin.gradients[i3];
			} else {
				let theta = Math.random() * 2 * Math.PI;
				g_vect3 = dropecho_noise_Perlin.gradients[i3] = { x : Math.cos(theta), y : Math.sin(theta)};
			}
			let xt = (top_right - top_left) * (3.0 - df * 2.0) * df * df + top_left;
			let w = y1 - yf;
			val += ((((x1 - xf1) * g_vect3.x + (y1 - yf1) * g_vect3.y - bottom_left) * (3.0 - df * 2.0) * df * df + bottom_left - xt) * (3.0 - w * 2.0) * w * w + xt) * amp;
			amp *= this.persistence;
			freq *= this.lacunarity;
		}
		return val;
	}
	static randomVector() {
		let theta = Math.random() * 2 * Math.PI;
		return { x : Math.cos(theta), y : Math.sin(theta)};
	}
	static dot_prod_grid(x,y,vx,vy) {
		let i = vy % 16 * 16 + vx % 16;
		let g_vect;
		if(dropecho_noise_Perlin.gradients[i] != null) {
			g_vect = dropecho_noise_Perlin.gradients[i];
		} else {
			let theta = Math.random() * 2 * Math.PI;
			g_vect = dropecho_noise_Perlin.gradients[i] = { x : Math.cos(theta), y : Math.sin(theta)};
		}
		return (x - vx) * g_vect.x + (y - vy) * g_vect.y;
	}
	static interpolate(w,a0,a1) {
		return (a1 - a0) * (3.0 - w * 2.0) * w * w + a0;
	}
	static noise(x,y) {
		let xf = x | 0;
		let yf = y | 0;
		let xf1 = xf + 1;
		let yf1 = yf + 1;
		let df = x - xf;
		let i = yf % 16 * 16 + xf % 16;
		let g_vect;
		if(dropecho_noise_Perlin.gradients[i] != null) {
			g_vect = dropecho_noise_Perlin.gradients[i];
		} else {
			let theta = Math.random() * 2 * Math.PI;
			g_vect = dropecho_noise_Perlin.gradients[i] = { x : Math.cos(theta), y : Math.sin(theta)};
		}
		let top_left = (x - xf) * g_vect.x + (y - yf) * g_vect.y;
		let i1 = yf % 16 * 16 + xf1 % 16;
		let g_vect1;
		if(dropecho_noise_Perlin.gradients[i1] != null) {
			g_vect1 = dropecho_noise_Perlin.gradients[i1];
		} else {
			let theta = Math.random() * 2 * Math.PI;
			g_vect1 = dropecho_noise_Perlin.gradients[i1] = { x : Math.cos(theta), y : Math.sin(theta)};
		}
		let top_right = (x - xf1) * g_vect1.x + (y - yf) * g_vect1.y;
		let i2 = yf1 % 16 * 16 + xf % 16;
		let g_vect2;
		if(dropecho_noise_Perlin.gradients[i2] != null) {
			g_vect2 = dropecho_noise_Perlin.gradients[i2];
		} else {
			let theta = Math.random() * 2 * Math.PI;
			g_vect2 = dropecho_noise_Perlin.gradients[i2] = { x : Math.cos(theta), y : Math.sin(theta)};
		}
		let bottom_left = (x - xf) * g_vect2.x + (y - yf1) * g_vect2.y;
		let i3 = yf1 % 16 * 16 + xf1 % 16;
		let g_vect3;
		if(dropecho_noise_Perlin.gradients[i3] != null) {
			g_vect3 = dropecho_noise_Perlin.gradients[i3];
		} else {
			let theta = Math.random() * 2 * Math.PI;
			g_vect3 = dropecho_noise_Perlin.gradients[i3] = { x : Math.cos(theta), y : Math.sin(theta)};
		}
		let xt = (top_right - top_left) * (3.0 - df * 2.0) * df * df + top_left;
		let w = y - yf;
		return (((x - xf1) * g_vect3.x + (y - yf1) * g_vect3.y - bottom_left) * (3.0 - df * 2.0) * df * df + bottom_left - xt) * (3.0 - w * 2.0) * w * w + xt;
	}
}
$hx_exports["dropecho"]["noise"]["Perlin"] = dropecho_noise_Perlin;
dropecho_noise_Perlin.__name__ = true;
class dropecho_noise_Pow {
	constructor(input,input2) {
		this.input2 = input2;
		this.input = input;
	}
	value(x,y) {
		return Math.pow(this.input.value(x,y),this.input2.value(x,y));
	}
}
$hx_exports["dropecho"]["noise"]["Pow"] = dropecho_noise_Pow;
dropecho_noise_Pow.__name__ = true;
class dropecho_noise_Ridged {
	constructor(octaves,frequency,amplitude,lacunarity,persistence) {
		if(persistence == null) {
			persistence = 1;
		}
		if(lacunarity == null) {
			lacunarity = 2;
		}
		if(amplitude == null) {
			amplitude = 1;
		}
		if(frequency == null) {
			frequency = 1;
		}
		if(octaves == null) {
			octaves = 1;
		}
		this.persistence = persistence;
		this.octaves = octaves;
		this.lacunarity = lacunarity;
		this.frequency = frequency;
		this.amplitude = amplitude;
	}
	value(x,y) {
		let max = 0;
		let val = 0;
		let currentAmplitude = this.amplitude;
		let currentFrequency = this.frequency;
		let currentValue;
		let _g = 0;
		let _g1 = this.octaves;
		while(_g < _g1) {
			++_g;
			currentValue = dropecho_noise_Simplex.noise(x * currentFrequency,y * currentFrequency,0) * currentAmplitude;
			max += currentAmplitude;
			currentAmplitude *= this.persistence;
			currentFrequency *= this.lacunarity;
			val += max - Math.abs(currentValue);
			val *= val / max;
		}
		return val / Math.pow(max,this.octaves) - this.amplitude;
	}
}
$hx_exports["dropecho"]["noise"]["Ridged"] = dropecho_noise_Ridged;
dropecho_noise_Ridged.__name__ = true;
class dropecho_noise_Scale {
	constructor(input,s) {
		this._input = input;
		this._scalar = s;
	}
	value(x,y) {
		return this._input.value(x * this._scalar,y * this._scalar);
	}
}
$hx_exports["dropecho"]["noise"]["Scale"] = dropecho_noise_Scale;
dropecho_noise_Scale.__name__ = true;
class dropecho_noise_Simplex {
	constructor(octaves,frequency,amplitude,lacunarity,persistence) {
		if(persistence == null) {
			persistence = 1;
		}
		if(lacunarity == null) {
			lacunarity = 2;
		}
		if(amplitude == null) {
			amplitude = 1;
		}
		if(frequency == null) {
			frequency = 1;
		}
		if(octaves == null) {
			octaves = 1;
		}
		this.persistence = persistence;
		this.octaves = octaves;
		this.lacunarity = lacunarity;
		this.frequency = frequency;
		this.amplitude = amplitude;
	}
	value(x,y) {
		let max = 0;
		let val = 0;
		let amp = this.amplitude;
		let freq = this.frequency;
		let _g = 0;
		let _g1 = this.octaves;
		while(_g < _g1) {
			++_g;
			val += dropecho_noise_Simplex.noise(x * freq,y * freq,0) * amp;
			max += amp;
			amp *= this.persistence;
			freq *= this.lacunarity;
		}
		return val / max;
	}
	static dot3(g,x,y,z) {
		return g[0] * x + g[1] * y + g[2] * z;
	}
	static noise(xin,yin,zin) {
		let n0;
		let n1;
		let n2;
		let n3;
		let s = (xin + yin + zin) * dropecho_noise_Simplex.F3;
		let f = xin + s;
		let i = f >= 0 ? f | 0 : f - 1 | 0;
		let f1 = yin + s;
		let j = f1 >= 0 ? f1 | 0 : f1 - 1 | 0;
		let f2 = zin + s;
		let k = f2 >= 0 ? f2 | 0 : f2 - 1 | 0;
		let t = (i + j + k) * dropecho_noise_Simplex.G3;
		let x0 = xin - (i - t);
		let y0 = yin - (j - t);
		let z0 = zin - (k - t);
		let i1;
		let j1;
		let k1;
		let i2;
		let j2;
		let k2;
		if(x0 >= y0) {
			if(y0 >= z0) {
				i1 = 1;
				j1 = 0;
				k1 = 0;
				i2 = 1;
				j2 = 1;
				k2 = 0;
			} else if(x0 >= z0) {
				i1 = 1;
				j1 = 0;
				k1 = 0;
				i2 = 1;
				j2 = 0;
				k2 = 1;
			} else {
				i1 = 0;
				j1 = 0;
				k1 = 1;
				i2 = 1;
				j2 = 0;
				k2 = 1;
			}
		} else if(y0 < z0) {
			i1 = 0;
			j1 = 0;
			k1 = 1;
			i2 = 0;
			j2 = 1;
			k2 = 1;
		} else if(x0 < z0) {
			i1 = 0;
			j1 = 1;
			k1 = 0;
			i2 = 0;
			j2 = 1;
			k2 = 1;
		} else {
			i1 = 0;
			j1 = 1;
			k1 = 0;
			i2 = 1;
			j2 = 1;
			k2 = 0;
		}
		let x1 = x0 - i1 + dropecho_noise_Simplex.G3;
		let y1 = y0 - j1 + dropecho_noise_Simplex.G3;
		let z1 = z0 - k1 + dropecho_noise_Simplex.G3;
		let x2 = x0 - i2 + 2.0 * dropecho_noise_Simplex.G3;
		let y2 = y0 - j2 + 2.0 * dropecho_noise_Simplex.G3;
		let z2 = z0 - k2 + 2.0 * dropecho_noise_Simplex.G3;
		let x3 = x0 - 1.0 + 3.0 * dropecho_noise_Simplex.G3;
		let y3 = y0 - 1.0 + 3.0 * dropecho_noise_Simplex.G3;
		let z3 = z0 - 1.0 + 3.0 * dropecho_noise_Simplex.G3;
		let ii = i & 255;
		let jj = j & 255;
		let kk = k & 255;
		let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
		if(t0 < 0) {
			n0 = 0.0;
		} else {
			t0 *= t0;
			let g = dropecho_noise_Simplex.grad3[dropecho_noise_Simplex.perm[ii + dropecho_noise_Simplex.perm[jj + dropecho_noise_Simplex.perm[kk]]] % 12];
			n0 = t0 * t0 * (g[0] * x0 + g[1] * y0 + g[2] * z0);
		}
		let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
		if(t1 < 0) {
			n1 = 0.0;
		} else {
			t1 *= t1;
			let g = dropecho_noise_Simplex.grad3[dropecho_noise_Simplex.perm[ii + i1 + dropecho_noise_Simplex.perm[jj + j1 + dropecho_noise_Simplex.perm[kk + k1]]] % 12];
			n1 = t1 * t1 * (g[0] * x1 + g[1] * y1 + g[2] * z1);
		}
		let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
		if(t2 < 0) {
			n2 = 0.0;
		} else {
			t2 *= t2;
			let g = dropecho_noise_Simplex.grad3[dropecho_noise_Simplex.perm[ii + i2 + dropecho_noise_Simplex.perm[jj + j2 + dropecho_noise_Simplex.perm[kk + k2]]] % 12];
			n2 = t2 * t2 * (g[0] * x2 + g[1] * y2 + g[2] * z2);
		}
		let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
		if(t3 < 0) {
			n3 = 0.0;
		} else {
			t3 *= t3;
			let g = dropecho_noise_Simplex.grad3[dropecho_noise_Simplex.perm[ii + 1 + dropecho_noise_Simplex.perm[jj + 1 + dropecho_noise_Simplex.perm[kk + 1]]] % 12];
			n3 = t3 * t3 * (g[0] * x3 + g[1] * y3 + g[2] * z3);
		}
		return 32.0 * (n0 + n1 + n2 + n3);
	}
}
$hx_exports["dropecho"]["noise"]["Simplex"] = dropecho_noise_Simplex;
dropecho_noise_Simplex.__name__ = true;
class dropecho_noise_Sub {
	constructor(input,input2) {
		this.input2 = input2;
		this.input = input;
	}
	value(x,y) {
		return this.input.value(x,y) - this.input2.value(x,y);
	}
}
$hx_exports["dropecho"]["noise"]["Sub"] = dropecho_noise_Sub;
dropecho_noise_Sub.__name__ = true;
class dropecho_noise_Terrace {
	constructor(input,points) {
		this.points = points;
		this.input = input;
	}
	value(x,y) {
		let v = this.input.value(x,y);
		if(this.points != null) {
			let _g = 0;
			let _g1 = this.points;
			while(_g < _g1.length) {
				let point = _g1[_g];
				++_g;
				if(v >= point.min && v < point.max) {
					return point.val;
				}
			}
		}
		return v;
	}
}
$hx_exports["dropecho"]["noise"]["Terrace"] = dropecho_noise_Terrace;
dropecho_noise_Terrace.__name__ = true;
class dropecho_noise_Voronoi {
	constructor(frequency,distanceType) {
		this.halfUnitVec = 0.353;
		this.frequency = frequency;
		this.distanceType = distanceType;
	}
	value(x,y) {
		x *= this.frequency;
		y *= this.frequency;
		let intX = x | 0;
		let intY = y | 0;
		let cell_x = x;
		let cell_y = y;
		let closest = { x : 0, y : 0, z : 0};
		let minDistToCandidate = Infinity;
		let _g = intX - 1;
		let _g1 = intX + 2;
		while(_g < _g1) {
			let cellX = _g++;
			let _g1 = intY - 1;
			let _g2 = intY + 2;
			while(_g1 < _g2) {
				let cellY = _g1++;
				let noiseX = dropecho_noise_Simplex.noise(cellX,cellY,0);
				noiseX = dropecho_utils_MathUtils.clamp(noiseX,-this.halfUnitVec,this.halfUnitVec);
				let noiseY = dropecho_noise_Simplex.noise(cellY,cellX,cellX * cellY);
				noiseY = dropecho_utils_MathUtils.clamp(noiseY,-this.halfUnitVec,this.halfUnitVec);
				let candidate = { x : cellX + noiseX, y : cellY + noiseY, z : 0.0};
				let distToCandidate;
				switch(this.distanceType) {
				case 1:
					distToCandidate = Math.abs(candidate.x - cell_x) + Math.abs(candidate.y - cell_y) + Math.abs(candidate.z);
					break;
				case 2:
					distToCandidate = Math.max(Math.max(candidate.x - cell_x,candidate.y - cell_y),candidate.z);
					break;
				default:
					let dx = candidate.x - cell_x;
					let dy = candidate.y - cell_y;
					let dz = candidate.z;
					distToCandidate = dx * dx + dy * dy + dz * dz;
				}
				if(distToCandidate < minDistToCandidate) {
					closest = candidate;
					minDistToCandidate = distToCandidate;
				}
			}
		}
		return dropecho_noise_Simplex.noise(closest.x,closest.y,closest.x * closest.y);
	}
	distance(a,b) {
		switch(this.distanceType) {
		case 1:
			return Math.abs(b.x - a.x) + Math.abs(b.y - a.y) + Math.abs(b.z - a.z);
		case 2:
			return Math.max(Math.max(b.x - a.x,b.y - a.y),b.z - a.z);
		default:
			let dx = b.x - a.x;
			let dy = b.y - a.y;
			let dz = b.z - a.z;
			return dx * dx + dy * dy + dz * dz;
		}
	}
}
$hx_exports["dropecho"]["noise"]["Voronoi"] = dropecho_noise_Voronoi;
dropecho_noise_Voronoi.__name__ = true;
class dropecho_noise_Worley {
	constructor(frequency) {
		this.yCells = [0,0,0];
		this.xCells = [0,0,0];
		this.frequency = 0.35;
		this.halfUnitVec = 0.35;
		this.frequency = frequency;
	}
	value(x,y) {
		x *= this.frequency;
		y *= this.frequency;
		let intX = x | 0;
		let intY = y | 0;
		let cell_x = x;
		let cell_y = y;
		let minDistToCandidate = Infinity;
		this.xCells[0] = intX - 1;
		this.xCells[1] = intX;
		this.xCells[2] = intX + 1;
		this.yCells[0] = intY - 1;
		this.yCells[1] = intY;
		this.yCells[2] = intY + 1;
		let _g = 0;
		let _g1 = this.xCells;
		while(_g < _g1.length) {
			let cellX = _g1[_g];
			++_g;
			let _g2 = 0;
			let _g3 = this.yCells;
			while(_g2 < _g3.length) {
				let cellY = _g3[_g2];
				++_g2;
				let noiseX = dropecho_noise_Simplex.noise(cellX,cellY,0);
				let this_x = cell_x - (cellX + dropecho_utils_MathUtils.clamp(noiseX,-this.halfUnitVec,this.halfUnitVec));
				let this_y = cell_y - (cellY + dropecho_utils_MathUtils.clamp(-noiseX,-this.halfUnitVec,this.halfUnitVec));
				let distToCandidate = this_x * this_x + this_y * this_y;
				if(distToCandidate < minDistToCandidate) {
					minDistToCandidate = distToCandidate;
				}
			}
		}
		return Math.sqrt(minDistToCandidate) * 2 - 1;
	}
}
$hx_exports["dropecho"]["noise"]["Worley"] = dropecho_noise_Worley;
dropecho_noise_Worley.__name__ = true;
class dropecho_utils_FastMath {
	static min(a,b) {
		if(a < b) {
			return a;
		} else {
			return b;
		}
	}
	static max(a,b) {
		if(a > b) {
			return a;
		} else {
			return b;
		}
	}
	static abs(f) {
		if(f < 0) {
			return -f;
		} else {
			return f;
		}
	}
	static sqrt(f) {
		return Math.sqrt(f);
	}
	static floor(f) {
		if(f >= 0) {
			return f | 0;
		} else {
			return f - 1 | 0;
		}
	}
	static round(f) {
		if(f >= 0) {
			return f + 0.5 | 0;
		} else {
			return f - 0.5 | 0;
		}
	}
}
$hx_exports["dropecho"]["utils"]["FastMath"] = dropecho_utils_FastMath;
dropecho_utils_FastMath.__name__ = true;
class dropecho_utils_MathUtils {
	static easeBezier(t,p0,p1,p2,p3) {
		let t1 = dropecho_utils_MathUtils.clamp(t,0,1);
		return dropecho_utils_MathUtils.clamp(Math.pow(1 - t1,3) * p0 + 3 * Math.pow(1 - t1,2) * Math.pow(t1,2) * p1 + 3 * (1 - t1) * Math.pow(t1,2) * p2 + Math.pow(t1,3) * p3,0,1);
	}
	static lerp(t,a,b) {
		return a + t * (b - a);
	}
	static easeOutCirc(x) {
		return Math.sqrt(1 - Math.pow(x - 1,2));
	}
	static easeOutSine(x) {
		return Math.sin(x * Math.PI / 2);
	}
	static easeInSine(x) {
		return 1 - Math.cos(x * Math.PI / 2);
	}
	static sine(k) {
		return Math.sin(k);
	}
	static mapEasing(val,fromMin,fromMax,toMin,toMax,easing) {
		return easing(1 + dropecho_utils_MathUtils.inverseLerp(val,fromMin,fromMax)) * (toMax - toMin);
	}
	static map(val,fromMin,fromMax,toMin,toMax) {
		return dropecho_utils_MathUtils.mapEasing(val,fromMin,fromMax,toMin,toMax,function(k) {
			return k;
		});
	}
	static inverseLerp(t,a,b) {
		return (t - a) / (b - a);
	}
	static clamp(val,min,max) {
		return Math.max(min,Math.min(val,max));
	}
}
$hx_exports["dropecho"]["utils"]["MathUtils"] = dropecho_utils_MathUtils;
dropecho_utils_MathUtils.__name__ = true;
class dropecho_utils_NoiseGen {
	constructor() {
		this.seed = 1;
	}
	nextInt() {
		return this.seed = this.seed * 16807 % 2147483647;
	}
	nextDouble() {
		return (this.seed = this.seed * 16807 % 2147483647) / 2147483647;
	}
	nextBoolean() {
		return (this.seed = this.seed * 16807 % 2147483647) % 2 == 0;
	}
	nextIntRange(min,max) {
		return Math.round(min + (max - min) * ((this.seed = this.seed * 16807 % 2147483647) / 2147483647));
	}
	nextDoubleRange(min,max) {
		return min + (max - min) * ((this.seed = this.seed * 16807 % 2147483647) / 2147483647);
	}
	gen() {
		return this.seed = this.seed * 16807 % 2147483647;
	}
}
$hx_exports["dropecho"]["utils"]["NoiseGen"] = dropecho_utils_NoiseGen;
dropecho_utils_NoiseGen.__name__ = true;
class dropecho_utils_TypeBuildingMacros {
	static isEmpty(expr) {
		if(expr == null) {
			return true;
		}
		let _g = expr.expr;
		if(_g._hx_index == 12) {
			return _g.exprs.length == 0;
		} else {
			return false;
		}
	}
	static makeField(arg,pos,doc) {
		let docRegex = new EReg("\\*\\s@param\\s" + arg.name + "\\s-?\\s?(.*)","i");
		let val = arg.value != null ? haxe_macro_ExprTools.getValue(arg.value) : null;
		let d = "";
		if(doc != null && docRegex.match(doc)) {
			d = docRegex.matched(1) + "\nDefault: " + val;
		}
		return { name : arg.name, doc : d, meta : [], access : [haxe_macro_Access.APrivate], kind : haxe_macro_FieldType.FVar(arg.type), pos : pos};
	}
}
$hx_exports["dropecho"]["utils"]["TypeBuildingMacros"] = dropecho_utils_TypeBuildingMacros;
dropecho_utils_TypeBuildingMacros.__name__ = true;
class dropecho_utils_Vector3 {
	static _new(i) {
		return i;
	}
	static fromIntVec1(b) {
		return { x : b.x, y : b.y, z : b.z};
	}
	static fromIntVec2(b) {
		return { x : b.x, y : b.y, z : b.z};
	}
	static fromIntVec3(b) {
		return { x : b.x, y : b.y, z : b.z};
	}
	static fromIntVec4(b) {
		return { x : b.x, y : b.y, z : b.z};
	}
	static fromIntVec5(b) {
		return { x : b.x, y : b.y, z : b.z};
	}
	static fromIntVec6(b) {
		return { x : b.x, y : b.y, z : b.z};
	}
	static add(this1,rhs) {
		return { x : this1.x + rhs.x, y : this1.y + rhs.y, z : this1.z + rhs.z};
	}
	static sub(this1,rhs) {
		return { x : this1.x - rhs.x, y : this1.y - rhs.y, z : this1.z - rhs.z};
	}
	static scale(this1,rhs) {
		return { x : this1.x * rhs, y : this1.y * rhs, z : this1.z * rhs};
	}
	static length(this1) {
		return Math.sqrt(this1.x * this1.x + this1.y * this1.y + this1.z * this1.z);
	}
	static lengthsq(this1) {
		return this1.x * this1.x + this1.y * this1.y + this1.z * this1.z;
	}
	static floor(this1) {
		return { x : Math.floor(this1.x), y : Math.floor(this1.y), z : Math.floor(this1.z)};
	}
}
$hx_exports["dropecho"]["utils"]["Vector3"] = dropecho_utils_Vector3;
class dropecho_utils_VectorMath {
	static rand3(a,seed) {
		let n = (a.x | 0) * dropecho_utils_VectorMath.magicX + (a.y | 0) * dropecho_utils_VectorMath.magicY + (a.z | 0) * dropecho_utils_VectorMath.magicZ + seed * dropecho_utils_VectorMath.magicS & 2147483647;
		n = n >> 13 ^ n;
		return 1.0 - (n * (n * n) & 2147483647) / 1073741824.0;
	}
	static rand3Int(x,y,z,seed) {
		let n = x * dropecho_utils_VectorMath.magicX + y * dropecho_utils_VectorMath.magicY + z * dropecho_utils_VectorMath.magicZ + seed * dropecho_utils_VectorMath.magicS & 2147483647;
		n = n >> 13 ^ n;
		return n * (n * n) & 2147483647;
	}
	static rand3dTo3d(a) {
		let n = (a.x | 0) * dropecho_utils_VectorMath.magicX + (a.y | 0) * dropecho_utils_VectorMath.magicY + (a.z | 0) * dropecho_utils_VectorMath.magicZ + 0 * dropecho_utils_VectorMath.magicS & 2147483647;
		n = n >> 13 ^ n;
		let rx = 1.0 - (n * (n * n) & 2147483647) / 1073741824.0;
		let n1 = (a.x | 0) * dropecho_utils_VectorMath.magicX + (a.y | 0) * dropecho_utils_VectorMath.magicY + (a.z | 0) * dropecho_utils_VectorMath.magicZ + dropecho_utils_VectorMath.magicS & 2147483647;
		n1 = n1 >> 13 ^ n1;
		let ry = 1.0 - (n1 * (n1 * n1) & 2147483647) / 1073741824.0;
		return { x : rx - Math.floor(rx), y : ry - Math.floor(ry), z : 0};
	}
	static add(a,b) {
		return { x : a.x + b.x, y : a.y + b.y, z : a.z + b.z};
	}
	static sub(a,b) {
		return { x : a.x - b.x, y : a.y - b.y, z : a.z - b.z};
	}
	static abs(a) {
		return { x : Math.abs(a.x), y : Math.abs(a.y), z : Math.abs(a.z)};
	}
	static distance(a,b) {
		let dx = b.x - a.x;
		let dy = b.y - a.y;
		let dz = b.z - a.z;
		return Math.sqrt(dx * dx + dy * dy + dz * dz);
	}
	static distanceSq(a,b) {
		let dx = b.x - a.x;
		let dy = b.y - a.y;
		let dz = b.z - a.z;
		return dx * dx + dy * dy + dz * dz;
	}
	static chebyshevDistance(a,b) {
		return Math.max(Math.max(b.x - a.x,b.y - a.y),b.z - a.z);
	}
	static manhattanDistance(a,b) {
		return Math.abs(b.x - a.x) + Math.abs(b.y - a.y) + Math.abs(b.z - a.z);
	}
	static length(a) {
		return Math.sqrt(a.x * a.x + a.y * a.y + a.z * a.z);
	}
	static lengthsq(a) {
		return a.x * a.x + a.y * a.y + a.z * a.z;
	}
	static scale(a,scalar) {
		return { x : a.x * scalar, y : a.y * scalar, z : a.z * scalar};
	}
	static inverseSqrt(a) {
		let number = a.x * a.x + a.y * a.y + a.z * a.z;
		let y = number;
		y = 1597463007 - ((number | 0) >> 1);
		y *= 1.5 - number * 0.5 * y * y;
		return y;
	}
	static normalize(a) {
		let number = a.x * a.x + a.y * a.y + a.z * a.z;
		let y = number;
		y = 1597463007 - ((number | 0) >> 1);
		let scalar = y *= 1.5 - number * 0.5 * y * y;
		return { x : a.x * scalar, y : a.y * scalar, z : a.z * scalar};
	}
	static dot(a,b) {
		return a.x * b.x + a.y * b.y + a.z * b.z;
	}
	static floor(a) {
		return { x : Math.floor(a.x), y : Math.floor(a.y), z : Math.floor(a.z)};
	}
}
$hx_exports["dropecho"]["utils"]["VectorMath"] = dropecho_utils_VectorMath;
dropecho_utils_VectorMath.__name__ = true;
class haxe_Exception extends Error {
	constructor(message,previous,native) {
		super(message);
		this.message = message;
		this.__previousException = previous;
		this.__nativeException = native != null ? native : this;
	}
	get_native() {
		return this.__nativeException;
	}
	static thrown(value) {
		if(((value) instanceof haxe_Exception)) {
			return value.get_native();
		} else if(((value) instanceof Error)) {
			return value;
		} else {
			let e = new haxe_ValueException(value);
			return e;
		}
	}
}
haxe_Exception.__name__ = true;
class haxe_ValueException extends haxe_Exception {
	constructor(value,previous,native) {
		super(String(value),previous,native);
		this.value = value;
	}
}
haxe_ValueException.__name__ = true;
class haxe_ds_ObjectMap {
	constructor() {
		this.h = { __keys__ : { }};
	}
	set(key,value) {
		let id = key.__id__;
		if(id == null) {
			id = (key.__id__ = $global.$haxeUID++);
		}
		this.h[id] = value;
		this.h.__keys__[id] = key;
	}
}
haxe_ds_ObjectMap.__name__ = true;
class haxe_iterators_ArrayIterator {
	constructor(array) {
		this.current = 0;
		this.array = array;
	}
	hasNext() {
		return this.current < this.array.length;
	}
	next() {
		return this.array[this.current++];
	}
}
haxe_iterators_ArrayIterator.__name__ = true;
var haxe_macro_StringLiteralKind = $hxEnums["haxe.macro.StringLiteralKind"] = { __ename__:true,__constructs__:null
	,DoubleQuotes: {_hx_name:"DoubleQuotes",_hx_index:0,__enum__:"haxe.macro.StringLiteralKind",toString:$estr}
	,SingleQuotes: {_hx_name:"SingleQuotes",_hx_index:1,__enum__:"haxe.macro.StringLiteralKind",toString:$estr}
};
haxe_macro_StringLiteralKind.__constructs__ = [haxe_macro_StringLiteralKind.DoubleQuotes,haxe_macro_StringLiteralKind.SingleQuotes];
var haxe_macro_Constant = $hxEnums["haxe.macro.Constant"] = { __ename__:true,__constructs__:null
	,CInt: ($_=function(v,s) { return {_hx_index:0,v:v,s:s,__enum__:"haxe.macro.Constant",toString:$estr}; },$_._hx_name="CInt",$_.__params__ = ["v","s"],$_)
	,CFloat: ($_=function(f,s) { return {_hx_index:1,f:f,s:s,__enum__:"haxe.macro.Constant",toString:$estr}; },$_._hx_name="CFloat",$_.__params__ = ["f","s"],$_)
	,CString: ($_=function(s,kind) { return {_hx_index:2,s:s,kind:kind,__enum__:"haxe.macro.Constant",toString:$estr}; },$_._hx_name="CString",$_.__params__ = ["s","kind"],$_)
	,CIdent: ($_=function(s) { return {_hx_index:3,s:s,__enum__:"haxe.macro.Constant",toString:$estr}; },$_._hx_name="CIdent",$_.__params__ = ["s"],$_)
	,CRegexp: ($_=function(r,opt) { return {_hx_index:4,r:r,opt:opt,__enum__:"haxe.macro.Constant",toString:$estr}; },$_._hx_name="CRegexp",$_.__params__ = ["r","opt"],$_)
};
haxe_macro_Constant.__constructs__ = [haxe_macro_Constant.CInt,haxe_macro_Constant.CFloat,haxe_macro_Constant.CString,haxe_macro_Constant.CIdent,haxe_macro_Constant.CRegexp];
var haxe_macro_Binop = $hxEnums["haxe.macro.Binop"] = { __ename__:true,__constructs__:null
	,OpAdd: {_hx_name:"OpAdd",_hx_index:0,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpMult: {_hx_name:"OpMult",_hx_index:1,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpDiv: {_hx_name:"OpDiv",_hx_index:2,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpSub: {_hx_name:"OpSub",_hx_index:3,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpAssign: {_hx_name:"OpAssign",_hx_index:4,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpEq: {_hx_name:"OpEq",_hx_index:5,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpNotEq: {_hx_name:"OpNotEq",_hx_index:6,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpGt: {_hx_name:"OpGt",_hx_index:7,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpGte: {_hx_name:"OpGte",_hx_index:8,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpLt: {_hx_name:"OpLt",_hx_index:9,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpLte: {_hx_name:"OpLte",_hx_index:10,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpAnd: {_hx_name:"OpAnd",_hx_index:11,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpOr: {_hx_name:"OpOr",_hx_index:12,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpXor: {_hx_name:"OpXor",_hx_index:13,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpBoolAnd: {_hx_name:"OpBoolAnd",_hx_index:14,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpBoolOr: {_hx_name:"OpBoolOr",_hx_index:15,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpShl: {_hx_name:"OpShl",_hx_index:16,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpShr: {_hx_name:"OpShr",_hx_index:17,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpUShr: {_hx_name:"OpUShr",_hx_index:18,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpMod: {_hx_name:"OpMod",_hx_index:19,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpAssignOp: ($_=function(op) { return {_hx_index:20,op:op,__enum__:"haxe.macro.Binop",toString:$estr}; },$_._hx_name="OpAssignOp",$_.__params__ = ["op"],$_)
	,OpInterval: {_hx_name:"OpInterval",_hx_index:21,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpArrow: {_hx_name:"OpArrow",_hx_index:22,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpIn: {_hx_name:"OpIn",_hx_index:23,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpNullCoal: {_hx_name:"OpNullCoal",_hx_index:24,__enum__:"haxe.macro.Binop",toString:$estr}
};
haxe_macro_Binop.__constructs__ = [haxe_macro_Binop.OpAdd,haxe_macro_Binop.OpMult,haxe_macro_Binop.OpDiv,haxe_macro_Binop.OpSub,haxe_macro_Binop.OpAssign,haxe_macro_Binop.OpEq,haxe_macro_Binop.OpNotEq,haxe_macro_Binop.OpGt,haxe_macro_Binop.OpGte,haxe_macro_Binop.OpLt,haxe_macro_Binop.OpLte,haxe_macro_Binop.OpAnd,haxe_macro_Binop.OpOr,haxe_macro_Binop.OpXor,haxe_macro_Binop.OpBoolAnd,haxe_macro_Binop.OpBoolOr,haxe_macro_Binop.OpShl,haxe_macro_Binop.OpShr,haxe_macro_Binop.OpUShr,haxe_macro_Binop.OpMod,haxe_macro_Binop.OpAssignOp,haxe_macro_Binop.OpInterval,haxe_macro_Binop.OpArrow,haxe_macro_Binop.OpIn,haxe_macro_Binop.OpNullCoal];
var haxe_macro_Unop = $hxEnums["haxe.macro.Unop"] = { __ename__:true,__constructs__:null
	,OpIncrement: {_hx_name:"OpIncrement",_hx_index:0,__enum__:"haxe.macro.Unop",toString:$estr}
	,OpDecrement: {_hx_name:"OpDecrement",_hx_index:1,__enum__:"haxe.macro.Unop",toString:$estr}
	,OpNot: {_hx_name:"OpNot",_hx_index:2,__enum__:"haxe.macro.Unop",toString:$estr}
	,OpNeg: {_hx_name:"OpNeg",_hx_index:3,__enum__:"haxe.macro.Unop",toString:$estr}
	,OpNegBits: {_hx_name:"OpNegBits",_hx_index:4,__enum__:"haxe.macro.Unop",toString:$estr}
	,OpSpread: {_hx_name:"OpSpread",_hx_index:5,__enum__:"haxe.macro.Unop",toString:$estr}
};
haxe_macro_Unop.__constructs__ = [haxe_macro_Unop.OpIncrement,haxe_macro_Unop.OpDecrement,haxe_macro_Unop.OpNot,haxe_macro_Unop.OpNeg,haxe_macro_Unop.OpNegBits,haxe_macro_Unop.OpSpread];
var haxe_macro_EFieldKind = $hxEnums["haxe.macro.EFieldKind"] = { __ename__:true,__constructs__:null
	,Normal: {_hx_name:"Normal",_hx_index:0,__enum__:"haxe.macro.EFieldKind",toString:$estr}
	,Safe: {_hx_name:"Safe",_hx_index:1,__enum__:"haxe.macro.EFieldKind",toString:$estr}
};
haxe_macro_EFieldKind.__constructs__ = [haxe_macro_EFieldKind.Normal,haxe_macro_EFieldKind.Safe];
var haxe_macro_FunctionKind = $hxEnums["haxe.macro.FunctionKind"] = { __ename__:true,__constructs__:null
	,FAnonymous: {_hx_name:"FAnonymous",_hx_index:0,__enum__:"haxe.macro.FunctionKind",toString:$estr}
	,FNamed: ($_=function(name,inlined) { return {_hx_index:1,name:name,inlined:inlined,__enum__:"haxe.macro.FunctionKind",toString:$estr}; },$_._hx_name="FNamed",$_.__params__ = ["name","inlined"],$_)
	,FArrow: {_hx_name:"FArrow",_hx_index:2,__enum__:"haxe.macro.FunctionKind",toString:$estr}
};
haxe_macro_FunctionKind.__constructs__ = [haxe_macro_FunctionKind.FAnonymous,haxe_macro_FunctionKind.FNamed,haxe_macro_FunctionKind.FArrow];
var haxe_macro_ExprDef = $hxEnums["haxe.macro.ExprDef"] = { __ename__:true,__constructs__:null
	,EConst: ($_=function(c) { return {_hx_index:0,c:c,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_._hx_name="EConst",$_.__params__ = ["c"],$_)
	,EArray: ($_=function(e1,e2) { return {_hx_index:1,e1:e1,e2:e2,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_._hx_name="EArray",$_.__params__ = ["e1","e2"],$_)
	,EBinop: ($_=function(op,e1,e2) { return {_hx_index:2,op:op,e1:e1,e2:e2,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_._hx_name="EBinop",$_.__params__ = ["op","e1","e2"],$_)
	,EField: ($_=function(e,field,kind) { return {_hx_index:3,e:e,field:field,kind:kind,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_._hx_name="EField",$_.__params__ = ["e","field","kind"],$_)
	,EParenthesis: ($_=function(e) { return {_hx_index:4,e:e,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_._hx_name="EParenthesis",$_.__params__ = ["e"],$_)
	,EObjectDecl: ($_=function(fields) { return {_hx_index:5,fields:fields,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_._hx_name="EObjectDecl",$_.__params__ = ["fields"],$_)
	,EArrayDecl: ($_=function(values) { return {_hx_index:6,values:values,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_._hx_name="EArrayDecl",$_.__params__ = ["values"],$_)
	,ECall: ($_=function(e,params) { return {_hx_index:7,e:e,params:params,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_._hx_name="ECall",$_.__params__ = ["e","params"],$_)
	,ENew: ($_=function(t,params) { return {_hx_index:8,t:t,params:params,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_._hx_name="ENew",$_.__params__ = ["t","params"],$_)
	,EUnop: ($_=function(op,postFix,e) { return {_hx_index:9,op:op,postFix:postFix,e:e,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_._hx_name="EUnop",$_.__params__ = ["op","postFix","e"],$_)
	,EVars: ($_=function(vars) { return {_hx_index:10,vars:vars,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_._hx_name="EVars",$_.__params__ = ["vars"],$_)
	,EFunction: ($_=function(kind,f) { return {_hx_index:11,kind:kind,f:f,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_._hx_name="EFunction",$_.__params__ = ["kind","f"],$_)
	,EBlock: ($_=function(exprs) { return {_hx_index:12,exprs:exprs,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_._hx_name="EBlock",$_.__params__ = ["exprs"],$_)
	,EFor: ($_=function(it,expr) { return {_hx_index:13,it:it,expr:expr,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_._hx_name="EFor",$_.__params__ = ["it","expr"],$_)
	,EIf: ($_=function(econd,eif,eelse) { return {_hx_index:14,econd:econd,eif:eif,eelse:eelse,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_._hx_name="EIf",$_.__params__ = ["econd","eif","eelse"],$_)
	,EWhile: ($_=function(econd,e,normalWhile) { return {_hx_index:15,econd:econd,e:e,normalWhile:normalWhile,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_._hx_name="EWhile",$_.__params__ = ["econd","e","normalWhile"],$_)
	,ESwitch: ($_=function(e,cases,edef) { return {_hx_index:16,e:e,cases:cases,edef:edef,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_._hx_name="ESwitch",$_.__params__ = ["e","cases","edef"],$_)
	,ETry: ($_=function(e,catches) { return {_hx_index:17,e:e,catches:catches,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_._hx_name="ETry",$_.__params__ = ["e","catches"],$_)
	,EReturn: ($_=function(e) { return {_hx_index:18,e:e,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_._hx_name="EReturn",$_.__params__ = ["e"],$_)
	,EBreak: {_hx_name:"EBreak",_hx_index:19,__enum__:"haxe.macro.ExprDef",toString:$estr}
	,EContinue: {_hx_name:"EContinue",_hx_index:20,__enum__:"haxe.macro.ExprDef",toString:$estr}
	,EUntyped: ($_=function(e) { return {_hx_index:21,e:e,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_._hx_name="EUntyped",$_.__params__ = ["e"],$_)
	,EThrow: ($_=function(e) { return {_hx_index:22,e:e,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_._hx_name="EThrow",$_.__params__ = ["e"],$_)
	,ECast: ($_=function(e,t) { return {_hx_index:23,e:e,t:t,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_._hx_name="ECast",$_.__params__ = ["e","t"],$_)
	,EDisplay: ($_=function(e,displayKind) { return {_hx_index:24,e:e,displayKind:displayKind,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_._hx_name="EDisplay",$_.__params__ = ["e","displayKind"],$_)
	,ETernary: ($_=function(econd,eif,eelse) { return {_hx_index:25,econd:econd,eif:eif,eelse:eelse,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_._hx_name="ETernary",$_.__params__ = ["econd","eif","eelse"],$_)
	,ECheckType: ($_=function(e,t) { return {_hx_index:26,e:e,t:t,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_._hx_name="ECheckType",$_.__params__ = ["e","t"],$_)
	,EMeta: ($_=function(s,e) { return {_hx_index:27,s:s,e:e,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_._hx_name="EMeta",$_.__params__ = ["s","e"],$_)
	,EIs: ($_=function(e,t) { return {_hx_index:28,e:e,t:t,__enum__:"haxe.macro.ExprDef",toString:$estr}; },$_._hx_name="EIs",$_.__params__ = ["e","t"],$_)
};
haxe_macro_ExprDef.__constructs__ = [haxe_macro_ExprDef.EConst,haxe_macro_ExprDef.EArray,haxe_macro_ExprDef.EBinop,haxe_macro_ExprDef.EField,haxe_macro_ExprDef.EParenthesis,haxe_macro_ExprDef.EObjectDecl,haxe_macro_ExprDef.EArrayDecl,haxe_macro_ExprDef.ECall,haxe_macro_ExprDef.ENew,haxe_macro_ExprDef.EUnop,haxe_macro_ExprDef.EVars,haxe_macro_ExprDef.EFunction,haxe_macro_ExprDef.EBlock,haxe_macro_ExprDef.EFor,haxe_macro_ExprDef.EIf,haxe_macro_ExprDef.EWhile,haxe_macro_ExprDef.ESwitch,haxe_macro_ExprDef.ETry,haxe_macro_ExprDef.EReturn,haxe_macro_ExprDef.EBreak,haxe_macro_ExprDef.EContinue,haxe_macro_ExprDef.EUntyped,haxe_macro_ExprDef.EThrow,haxe_macro_ExprDef.ECast,haxe_macro_ExprDef.EDisplay,haxe_macro_ExprDef.ETernary,haxe_macro_ExprDef.ECheckType,haxe_macro_ExprDef.EMeta,haxe_macro_ExprDef.EIs];
var haxe_macro_DisplayKind = $hxEnums["haxe.macro.DisplayKind"] = { __ename__:true,__constructs__:null
	,DKCall: {_hx_name:"DKCall",_hx_index:0,__enum__:"haxe.macro.DisplayKind",toString:$estr}
	,DKDot: {_hx_name:"DKDot",_hx_index:1,__enum__:"haxe.macro.DisplayKind",toString:$estr}
	,DKStructure: {_hx_name:"DKStructure",_hx_index:2,__enum__:"haxe.macro.DisplayKind",toString:$estr}
	,DKMarked: {_hx_name:"DKMarked",_hx_index:3,__enum__:"haxe.macro.DisplayKind",toString:$estr}
	,DKPattern: ($_=function(outermost) { return {_hx_index:4,outermost:outermost,__enum__:"haxe.macro.DisplayKind",toString:$estr}; },$_._hx_name="DKPattern",$_.__params__ = ["outermost"],$_)
};
haxe_macro_DisplayKind.__constructs__ = [haxe_macro_DisplayKind.DKCall,haxe_macro_DisplayKind.DKDot,haxe_macro_DisplayKind.DKStructure,haxe_macro_DisplayKind.DKMarked,haxe_macro_DisplayKind.DKPattern];
var haxe_macro_ComplexType = $hxEnums["haxe.macro.ComplexType"] = { __ename__:true,__constructs__:null
	,TPath: ($_=function(p) { return {_hx_index:0,p:p,__enum__:"haxe.macro.ComplexType",toString:$estr}; },$_._hx_name="TPath",$_.__params__ = ["p"],$_)
	,TFunction: ($_=function(args,ret) { return {_hx_index:1,args:args,ret:ret,__enum__:"haxe.macro.ComplexType",toString:$estr}; },$_._hx_name="TFunction",$_.__params__ = ["args","ret"],$_)
	,TAnonymous: ($_=function(fields) { return {_hx_index:2,fields:fields,__enum__:"haxe.macro.ComplexType",toString:$estr}; },$_._hx_name="TAnonymous",$_.__params__ = ["fields"],$_)
	,TParent: ($_=function(t) { return {_hx_index:3,t:t,__enum__:"haxe.macro.ComplexType",toString:$estr}; },$_._hx_name="TParent",$_.__params__ = ["t"],$_)
	,TExtend: ($_=function(p,fields) { return {_hx_index:4,p:p,fields:fields,__enum__:"haxe.macro.ComplexType",toString:$estr}; },$_._hx_name="TExtend",$_.__params__ = ["p","fields"],$_)
	,TOptional: ($_=function(t) { return {_hx_index:5,t:t,__enum__:"haxe.macro.ComplexType",toString:$estr}; },$_._hx_name="TOptional",$_.__params__ = ["t"],$_)
	,TNamed: ($_=function(n,t) { return {_hx_index:6,n:n,t:t,__enum__:"haxe.macro.ComplexType",toString:$estr}; },$_._hx_name="TNamed",$_.__params__ = ["n","t"],$_)
	,TIntersection: ($_=function(tl) { return {_hx_index:7,tl:tl,__enum__:"haxe.macro.ComplexType",toString:$estr}; },$_._hx_name="TIntersection",$_.__params__ = ["tl"],$_)
};
haxe_macro_ComplexType.__constructs__ = [haxe_macro_ComplexType.TPath,haxe_macro_ComplexType.TFunction,haxe_macro_ComplexType.TAnonymous,haxe_macro_ComplexType.TParent,haxe_macro_ComplexType.TExtend,haxe_macro_ComplexType.TOptional,haxe_macro_ComplexType.TNamed,haxe_macro_ComplexType.TIntersection];
var haxe_macro_Access = $hxEnums["haxe.macro.Access"] = { __ename__:true,__constructs__:null
	,APublic: {_hx_name:"APublic",_hx_index:0,__enum__:"haxe.macro.Access",toString:$estr}
	,APrivate: {_hx_name:"APrivate",_hx_index:1,__enum__:"haxe.macro.Access",toString:$estr}
	,AStatic: {_hx_name:"AStatic",_hx_index:2,__enum__:"haxe.macro.Access",toString:$estr}
	,AOverride: {_hx_name:"AOverride",_hx_index:3,__enum__:"haxe.macro.Access",toString:$estr}
	,ADynamic: {_hx_name:"ADynamic",_hx_index:4,__enum__:"haxe.macro.Access",toString:$estr}
	,AInline: {_hx_name:"AInline",_hx_index:5,__enum__:"haxe.macro.Access",toString:$estr}
	,AMacro: {_hx_name:"AMacro",_hx_index:6,__enum__:"haxe.macro.Access",toString:$estr}
	,AFinal: {_hx_name:"AFinal",_hx_index:7,__enum__:"haxe.macro.Access",toString:$estr}
	,AExtern: {_hx_name:"AExtern",_hx_index:8,__enum__:"haxe.macro.Access",toString:$estr}
	,AAbstract: {_hx_name:"AAbstract",_hx_index:9,__enum__:"haxe.macro.Access",toString:$estr}
	,AOverload: {_hx_name:"AOverload",_hx_index:10,__enum__:"haxe.macro.Access",toString:$estr}
};
haxe_macro_Access.__constructs__ = [haxe_macro_Access.APublic,haxe_macro_Access.APrivate,haxe_macro_Access.AStatic,haxe_macro_Access.AOverride,haxe_macro_Access.ADynamic,haxe_macro_Access.AInline,haxe_macro_Access.AMacro,haxe_macro_Access.AFinal,haxe_macro_Access.AExtern,haxe_macro_Access.AAbstract,haxe_macro_Access.AOverload];
var haxe_macro_FieldType = $hxEnums["haxe.macro.FieldType"] = { __ename__:true,__constructs__:null
	,FVar: ($_=function(t,e) { return {_hx_index:0,t:t,e:e,__enum__:"haxe.macro.FieldType",toString:$estr}; },$_._hx_name="FVar",$_.__params__ = ["t","e"],$_)
	,FFun: ($_=function(f) { return {_hx_index:1,f:f,__enum__:"haxe.macro.FieldType",toString:$estr}; },$_._hx_name="FFun",$_.__params__ = ["f"],$_)
	,FProp: ($_=function(get,set,t,e) { return {_hx_index:2,get:get,set:set,t:t,e:e,__enum__:"haxe.macro.FieldType",toString:$estr}; },$_._hx_name="FProp",$_.__params__ = ["get","set","t","e"],$_)
};
haxe_macro_FieldType.__constructs__ = [haxe_macro_FieldType.FVar,haxe_macro_FieldType.FFun,haxe_macro_FieldType.FProp];
class haxe_macro_ExprTools {
	static getValue(e) {
		while(true) {
			let _g = e.expr;
			switch(_g._hx_index) {
			case 0:
				let _g1 = _g.c;
				switch(_g1._hx_index) {
				case 0:
					return Std.parseInt(_g1.v);
				case 1:
					return parseFloat(_g1.f);
				case 2:
					return _g1.s;
				case 3:
					switch(_g1.s) {
					case "false":
						return false;
					case "null":
						return null;
					case "true":
						return true;
					default:
						throw haxe_Exception.thrown("Unsupported expression: " + Std.string(e));
					}
					break;
				default:
					throw haxe_Exception.thrown("Unsupported expression: " + Std.string(e));
				}
				break;
			case 2:
				let e1 = haxe_macro_ExprTools.getValue(_g.e1);
				let e2 = haxe_macro_ExprTools.getValue(_g.e2);
				switch(_g.op._hx_index) {
				case 0:
					return e1 + e2;
				case 1:
					return e1 * e2;
				case 2:
					return e1 / e2;
				case 3:
					return e1 - e2;
				case 5:
					return e1 == e2;
				case 6:
					return e1 != e2;
				case 7:
					return e1 > e2;
				case 8:
					return e1 >= e2;
				case 9:
					return e1 < e2;
				case 10:
					return e1 <= e2;
				case 11:
					return e1 & e2;
				case 12:
					return e1 | e2;
				case 13:
					return e1 ^ e2;
				case 14:
					if(e1) {
						return e2;
					} else {
						return false;
					}
					break;
				case 15:
					if(!e1) {
						return e2;
					} else {
						return true;
					}
					break;
				case 16:
					return e1 << e2;
				case 17:
					return e1 >> e2;
				case 18:
					return e1 >>> e2;
				case 19:
					return e1 % e2;
				default:
					throw haxe_Exception.thrown("Unsupported expression: " + Std.string(e));
				}
				break;
			case 4:
				e = _g.e;
				continue;
			case 5:
				let _g2 = _g.fields;
				let obj = { };
				let _g3 = 0;
				while(_g3 < _g2.length) {
					let field = _g2[_g3];
					++_g3;
					obj[field.field] = haxe_macro_ExprTools.getValue(field.expr);
				}
				return obj;
			case 6:
				let _g4 = _g.values;
				let f = haxe_macro_ExprTools.getValue;
				let result = new Array(_g4.length);
				let _g5 = 0;
				let _g6 = _g4.length;
				while(_g5 < _g6) {
					let i = _g5++;
					result[i] = f(_g4[i]);
				}
				return result;
			case 9:
				if(_g.postFix == false) {
					let e1 = haxe_macro_ExprTools.getValue(_g.e);
					switch(_g.op._hx_index) {
					case 2:
						return !e1;
					case 3:
						return -e1;
					case 4:
						return ~e1;
					default:
						throw haxe_Exception.thrown("Unsupported expression: " + Std.string(e));
					}
				} else {
					throw haxe_Exception.thrown("Unsupported expression: " + Std.string(e));
				}
				break;
			case 14:
				let _g7 = _g.eelse;
				if(_g7 == null) {
					throw haxe_Exception.thrown("If statements only have a value if the else clause is defined");
				} else if(haxe_macro_ExprTools.getValue(_g.econd)) {
					e = _g.eif;
					continue;
				} else {
					e = _g7;
					continue;
				}
				break;
			case 21:
				e = _g.e;
				continue;
			case 25:
				let _g8 = _g.eelse;
				if(_g8 == null) {
					throw haxe_Exception.thrown("If statements only have a value if the else clause is defined");
				} else if(haxe_macro_ExprTools.getValue(_g.econd)) {
					e = _g.eif;
					continue;
				} else {
					e = _g8;
					continue;
				}
				break;
			case 27:
				e = _g.e;
				continue;
			default:
				throw haxe_Exception.thrown("Unsupported expression: " + Std.string(e));
			}
		}
	}
}
haxe_macro_ExprTools.__name__ = true;
class js_Boot {
	static __string_rec(o,s) {
		if(o == null) {
			return "null";
		}
		if(s.length >= 5) {
			return "<...>";
		}
		let t = typeof(o);
		if(t == "function" && (o.__name__ || o.__ename__)) {
			t = "object";
		}
		switch(t) {
		case "function":
			return "<function>";
		case "object":
			if(o.__enum__) {
				let e = $hxEnums[o.__enum__];
				let con = e.__constructs__[o._hx_index];
				let n = con._hx_name;
				if(con.__params__) {
					s = s + "\t";
					return n + "(" + ((function($this) {
						var $r;
						let _g = [];
						{
							let _g1 = 0;
							let _g2 = con.__params__;
							while(true) {
								if(!(_g1 < _g2.length)) {
									break;
								}
								let p = _g2[_g1];
								_g1 = _g1 + 1;
								_g.push(js_Boot.__string_rec(o[p],s));
							}
						}
						$r = _g;
						return $r;
					}(this))).join(",") + ")";
				} else {
					return n;
				}
			}
			if(((o) instanceof Array)) {
				let str = "[";
				s += "\t";
				let _g = 0;
				let _g1 = o.length;
				while(_g < _g1) {
					let i = _g++;
					str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
				}
				str += "]";
				return str;
			}
			let tostr;
			try {
				tostr = o.toString;
			} catch( _g ) {
				return "???";
			}
			if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
				let s2 = o.toString();
				if(s2 != "[object Object]") {
					return s2;
				}
			}
			let str = "{\n";
			s += "\t";
			let hasp = o.hasOwnProperty != null;
			let k = null;
			for( k in o ) {
			if(hasp && !o.hasOwnProperty(k)) {
				continue;
			}
			if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
				continue;
			}
			if(str.length != 2) {
				str += ", \n";
			}
			str += s + k + " : " + js_Boot.__string_rec(o[k],s);
			}
			s = s.substring(1);
			str += "\n" + s + "}";
			return str;
		case "string":
			return o;
		default:
			return String(o);
		}
	}
}
js_Boot.__name__ = true;
$global.$haxeUID |= 0;
{
	String.__name__ = true;
	Array.__name__ = true;
}
js_Boot.__toStr = ({ }).toString;
dropecho_noise_Perlin.gradients = [];
dropecho_noise_Simplex.grad3 = [[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],[1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],[0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]];
dropecho_noise_Simplex.p = [151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];
dropecho_noise_Simplex.perm = (function($this) {
	var $r;
	let _g = [];
	{
		let _g1 = 0;
		while(_g1 < 512) _g.push(dropecho_noise_Simplex.p[_g1++ & 255]);
	}
	$r = _g;
	return $r;
}(this));
dropecho_noise_Simplex.F3 = 0.333333333333333315;
dropecho_noise_Simplex.G3 = 0.166666666666666657;
dropecho_utils_VectorMath.magicX = 9167;
dropecho_utils_VectorMath.magicY = 41179;
dropecho_utils_VectorMath.magicZ = 9167;
dropecho_utils_VectorMath.magicS = 4819;
})(typeof exports != "undefined" ? exports : typeof window != "undefined" ? window : typeof self != "undefined" ? self : this, typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
